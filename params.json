{"name":"x6502","tagline":"Yet another 6502 emulator that one day dreams of being an Atari 2600.","body":"# x6502: a simple 6502 CPU emulator\r\n\r\nx6502 is an emulator for the 6502 class of processors.\r\n    It currently supports the full instruction set of the\r\n    6502 (plus a few extensions) and has an extremely\r\n    rudimentary simulated I/O bus. It should be able to run\r\n    arbitrary x6502 bytecode with \"correct\" results,\r\n    although most binaries for common 6502 systems (Amiga,\r\n    C64, Apple II, etc) won't function as expected, since\r\n    they expect I/O devices to be mapped into memory where\r\n    there are currently none.\r\n\r\n## Building and running x6502\r\n\r\nTo build x6502, just run `make` in the project root. You\r\n    will need clang and Python installed. To use gcc, change\r\n    the `CC` var in the Makefile. No libraries beyond POSIX\r\n    libc are used. This will produce the x6502 binary.\r\n\r\nx6502 takes the compiled 6502 object file as an\r\n    argument, and runs it until it encounters an EXT\r\n    instruction (EXT instructions are an extension to 6502\r\n    bytecode, see below). You can use any 6502 assembler to\r\n    compile to 6502 bytecode; `xa` is one that is bundled\r\n    with Debian-based distros. Note that, by default, x6502\r\n    loads code in at address `0x00`; you therefore need to\r\n    either tell your assembler that that's the base address\r\n    for the text section of your binary or override the\r\n    default load address using the `-b` flag of x6502.\r\n\r\nIf you want to compile a version of x6502 that dumps\r\n    machine state after every instruction, run `make debug`\r\n    instead of `make`. This will also disable compiler\r\n    optimizations.\r\n\r\n## Extensions to the 6502 instruction set\r\n\r\nx6502 recognizes two instructions that are not in the\r\n    original 6502 instruction set. These are:\r\n\r\n- `DEBUG (0xFC)` prints debugging information about the current state of the emulator\r\n- `EXT (0xFF)` stops the emulator and exits\r\n\r\nBoth of these are defined as macros in `stdlib/stdio.s`.\r\n    To disable these extensions, compile with\r\n    `-DDISABLE_EXTENSIONS` (right now, this can be done by\r\n    adding that flag to the Makefile).\r\n\r\n## I/O memory map:\r\n\r\nThere are only two I/O devices right now: a character\r\n    input device and a character output device. Convenience\r\n    constants and macros for all I/O devices are defined in\r\n    `stdlib/stdio.s` for use in user programs. Add `stdlib/` to\r\n    your include path and then add `#include <stdio.s>` to\r\n    your program to use these constants.\r\n    \r\nThe character output device is mapped to `FF00`. Any\r\n    character written to `FF00` is immediately echoed to the\r\n    terminal.\r\n\r\nThe character input device is mapped to `FF01`. When a\r\n    character is available on standard in, an interrupt is\r\n    raised and `FF01` is set to the character that was\r\n    received. Note that one character is delivered per\r\n    interrupt; if the user types `abc`, they will get\r\n    three interrupts, one after the other.\r\n\r\nA commented example of how to use the I/O capabilities\r\n    of x6502 is provided in `test-programs/echo.s`.\r\n\r\n## Source code formatting\r\n\r\nThe code for opcode handling is a little strange; there\r\n    are lots of \"header\" files in the opcode_handlers\r\n    directory that are not really header files at all. These\r\n    files all contain code for handling opcode parsing and\r\n    interpretation; with over 150 opcodes, having all of the\r\n    code to handle these in one file would be excessive and\r\n    difficult to navigate, and dispatching out to functions\r\n    to handle each opcode carries unnecessary overhead in\r\n    what should be the tightest loop in the project. Thus,\r\n    each of these header files is `#include`d in `emu.c` in the\r\n    middle of a switch statement, and gets access to the\r\n    local scope within the `main_loop` function. It's weird\r\n    but it gets the job done, and is the least bad of all\r\n    considered options.\r\n\r\n## TODO:\r\n  - support buffered input, where the program can read\r\n    more than one input character at once.\r\n  - graphics? definitely more I/O.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}